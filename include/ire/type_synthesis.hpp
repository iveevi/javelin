#pragma once

#include "../thunder/atom.hpp"
#include "emitter.hpp"
#include "string_literal.hpp"
#include "tagged.hpp"
#include "type_system.hpp"
#include "uniform_layout.hpp"

namespace jvl::ire {

// Forward declarations
template <typename T>
constexpr thunder::PrimitiveType synthesize_primitive_type();

// Automatically determining layout types
template <string_literal name, builtin T>
inline auto field(const T &ref)
{
	return __field <name, T> (&static_cast <const tagged &> (ref), nullptr);
}

template <string_literal name, aggregate T>
inline auto field(const T &ref)
{
	using layout_t = decltype(T().layout());
	auto ptr = new layout_t(ref.layout());
	return __field <name, T> (nullptr, ptr);
}

#define named_field(name) field <#name> (name)

template <typename ... Ts, typename ... Us>
auto layout_cat(const_uniform_layout_t <Ts...>, const_uniform_layout_t <Us...>) -> const_uniform_layout_t <Ts..., Us...>;

template <typename ... Args>
struct layout_generator {
	using type = void;
};

template <typename T, string_literal name>
struct layout_generator <__field <name, T>> {
	using type = const_uniform_layout_t <T>;
};

template <typename T, string_literal name, typename ... Args>
struct layout_generator <__field <name, T>, Args...> {
	using single_type = const_uniform_layout_t <T>;
	using args_type = layout_generator <Args...> ::type;
	using type = decltype(layout_cat(single_type(), args_type()));
};

template <__field_type ... Args>
struct group_generator {
	static constexpr string_literal_group <Args::literal...> group = {};
};

template <string_literal_group group, typename ... Args>
struct higher_layout_combinator {
	using type = void;
};

template <string_literal_group group, typename ... Args>
struct higher_layout_combinator <group, const_uniform_layout_t <Args...>> {
	using type = higher_const_uniform_layout_t <group, Args...>;
};

// User end functions to specify members
template <typename ... Args>
auto uniform_layout(const std::string &name, const Args &... args)
{
	static_assert((__field_type <Args> && ...),
		"uniform_layout arguments should ALL be field types "
		"(i.e. generated by field <...> (...))");

	constexpr auto field_group_t = group_generator <Args...> ::group;
	using layout_base_t = typename layout_generator <Args...> ::type;
	using higher_layout_t = typename higher_layout_combinator <field_group_t, layout_base_t> ::type;

	higher_layout_t layout;
	layout.name = name;
	layout.fields.resize(sizeof...(Args));

	// Better (compile-time) error handling; no need to release
	// the compiler's error explosion to the user
	if constexpr ((__field_type <Args> && ...))
		__const_init(layout.fields.data(), 0, args...);

	return layout;
}

// Synthesize types for an entire sequence of arguments
[[gnu::always_inline]]
static inline bool valid(const thunder::TypeInformation &tf)
{
	// TODO: method
	return (tf.down != -1) || (tf.item != thunder::bad);
}

template <typename T>
struct type_info_override : std::false_type {
	type_info_override(const T &) {}
};

// Unique type index generation to track unique layouts
inline int64_t unique_type_idx = 0;

template <typename T>
int64_t type_idx()
{
	// Force ID fetch at runtime
	static int64_t c = -1;
	if (c == -1)
		c = unique_type_idx++;
	return c;
}

template <size_t I, generic T, generic ... Args>
cache_index_t type_field_from_args_impl()
{
	MODULE(type-field-from-args-impl);

	auto &em = Emitter::active;

	thunder::TypeInformation type_info;
	if constexpr (aggregate <T>) {
		auto layout = T().layout();
		auto cached = type_field_from_args(layout);
		auto fields = std::vector <std::string> ();

		for (auto &f : layout.fields)
			fields.push_back(f.name);

		em.emit_hint(cached.id, type_idx <T> (), layout.name, fields);

		// If its a single struct, then we should not nest
		if constexpr (I == 0 && sizeof...(Args) == 0)
			return cached;
		else
			type_info.down = cached.id;
	} else {
		using override = type_info_override <T>;

		if constexpr (override::value)
			type_info.down = override(T()).synthesize();
		else
			type_info.item = synthesize_primitive_type <T> ();
	}

	JVL_ASSERT(valid(type_info), "invalid type information was generated");

	if constexpr (sizeof...(Args))
		type_info.next = type_field_from_args_impl <I + 1, Args...> ().id;
	else
		type_info.next = -1;

	cache_index_t cached;
	cached = em.emit(type_info);
	return cached;
}

// Concrete alternative using concrete references...
template <size_t I, generic T, generic ... Args>
cache_index_t type_field_from_arg_refs_impl(const T &ref, const Args &... args)
{
	MODULE(type-field-from-args-impl);

	auto &em = Emitter::active;

	thunder::TypeInformation type_info;
	if constexpr (aggregate <T>) {
		auto layout = T().layout();
		auto cached = type_field_from_args(layout);
		auto fields = std::vector <std::string> ();

		for (auto &f : layout.fields)
			fields.push_back(f.name);

		em.emit_hint(cached.id, type_idx <T> (), layout.name, fields);

		// If its a single struct, then we should not nest
		if constexpr (I == 0 && sizeof...(Args) == 0)
			return cached;
		else
			type_info.down = cached.id;
	} else {
		using override = type_info_override <T>;

		if constexpr (override::value)
			type_info.down = override(ref).synthesize();
		else
			type_info.item = synthesize_primitive_type <T> ();
	}

	JVL_ASSERT(valid(type_info), "invalid type information was generated");

	if constexpr (sizeof...(Args))
		type_info.next = type_field_from_arg_refs_impl <I + 1, Args...> (args...).id;
	else
		type_info.next = -1;

	cache_index_t cached;
	cached = em.emit(type_info);
	return cached;
}

template <typename T, typename ... Args>
cache_index_t type_field_from_args()
{
	return type_field_from_args_impl <0, T, Args...> ();
}

template <typename ... Args>
cache_index_t type_field_from_args(const uniform_layout_t <Args...> &args)
{
	return type_field_from_args <Args...> ();
}

template <typename ... Args>
cache_index_t type_field_from_args(const const_uniform_layout_t <Args...> &args)
{
	return type_field_from_args <Args...> ();
}

// Synthesize types for a specific index from a sequence of arguments
template <typename T, typename ... Args>
cache_index_t type_field_index_from_args(int index)
{
	if constexpr (sizeof...(Args)) {
		if (index > 0)
			return type_field_index_from_args <Args...> (index);
	}

	auto &em = Emitter::active;

	thunder::TypeInformation type_info;
	if constexpr (aggregate <T>) {
		using layout_t = decltype(T().layout());
		type_info.down = type_field_from_args(layout_t()).id;
	} else {
		type_info.item = synthesize_primitive_type <T> ();
	}

	cache_index_t cached;
	cached = em.emit(type_info);
	return cached;
}

template <typename ... Args>
cache_index_t type_field_index_from_args(int index, const uniform_layout_t <Args...> &args)
{
	return type_field_index_from_args <Args...> (index);
}

template <typename ... Args>
cache_index_t type_field_index_from_args(int index, const const_uniform_layout_t <Args...> &args)
{
	return type_field_index_from_args <Args...> (index);
}

} // namespace jvl::ire
