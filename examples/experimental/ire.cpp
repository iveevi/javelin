// TODO: autodiff on inputs, for callables and shaders
// TODO: partial evaluation of callables through substitution methods
// TODO: external constant specialization
// TODO: atomics
// TODO: fix optimization...

#include <queue>

#include <glad/gl.h>
#include <GLFW/glfw3.h>

#include <common/io.hpp>

#include <ire.hpp>

#include <thunder/optimization.hpp>
#include <thunder/linkage_unit.hpp>

using namespace jvl;
using namespace jvl::ire;

MODULE(ire);

// TODO: type check for soft/concrete types... layout_from only for concrete types
// TODO: generic is anything,
// 	but solid_t aggregates must take only concrete_generics
//      and soft_t aggregates can take anything, defaults to solid_t is all concrete

// TODO: l-value propagation
// TODO: get line numbers for each invocation if possible?
// using source location if available

// Type safe options: shaders as functors...
struct Vertex {
	gl_Position_t gl_Position;

	// Override return capabilities
	struct _return_igniter {
		void operator<<(_void) const {
			fmt::println("Vertex return!");
			return _return();
		}
	};

	virtual void operator()() = 0;
};

template <generic_or_void R>
struct Subroutine {
	// Override return capabilities
	struct _return_igniter {
		void operator<<(R x) const {
			fmt::println("Subroutine return!");
			return _return(x);
		}
	};

	virtual void operator()() = 0;
};

// Examples...
struct Method : Subroutine <vec3> {
	void operator()() override {
		$return vec3(1);
	};
};

struct VMain : Vertex {
	void operator()() override {
		$return $void;
	}
};

// TODO: $strong_subroutine
// TODO: $strong_entrypoint
// ex. $strong_subroutine(R, name, resources...)(arguments...)
// TODO: and then partial specializable ones...

// TODO: linking raw shader (string) code as well...
// use as a test for shader toy examples

$subroutine(uvec3, pcg3d)(uvec3 v)
{
	v = v * 1664525u + 1013904223u;
	v.x += v.y * v.z;
	v.y += v.z * v.x;
	v.z += v.x * v.y;
	v ^= v >> 16u;
	v.x += v.y * v.z;
	v.y += v.z * v.x;
	v.z += v.x * v.y;
	return v;
};

$subroutine(vec3, random3)(inout <vec3> seed)
{
	seed = uintBitsToFloat((pcg3d(floatBitsToUint(seed)) & 0x007FFFFFu) | 0x3F800000u) - 1.0;
	return seed;
};

int main()
{
	auto demo = pcg3d;

	{
		auto glsl = link(demo).generate_glsl();
		io::display_lines("FTN", glsl);
	}

	// Before legalization, get rid of spurious constructions
	// and casts that were generated by the IR emitter
	// TODO: flags to only enable casting...
	Optimizer::stable.disolve(demo, thunder::DisolveFlags::eCasting);

	demo.display_assembly();

	// TODO: legalization pass for calls...
	Legalizer::stable.storage(demo);

	// TODO: for sanity, add a validation check before optimization
	// which checks for e.g. store destinations as storages... or
	// lvalues to global resources/parameters
	Optimizer::stable.apply(demo);
	
	{
		auto glsl = link(demo).generate_glsl();
		io::display_lines("FTN POST", glsl);
	}

	// demo.graphviz("ire.dot");

	// demo.display_assembly();
}
